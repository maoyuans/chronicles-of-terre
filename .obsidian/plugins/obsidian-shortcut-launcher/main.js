/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ShortcutLauncherPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/SettingsTab.ts
var import_obsidian2 = require("obsidian");

// src/LauncherModal.ts
var import_obsidian = require("obsidian");
var LauncherModal = class extends import_obsidian.Modal {
  constructor(app, isEditing, commandName, shortcutName, inputTypes, separator, onSave) {
    super(app);
    this.isEditing = isEditing;
    this.commandName = commandName;
    this.shortcutName = shortcutName;
    this.inputTypes = inputTypes;
    this.separator = separator;
    this.onSave = onSave;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", {
      text: this.isEditing ? "Edit Launcher" : "New Launcher"
    });
    new import_obsidian.Setting(contentEl).setName("Command Name").setDesc("The Obsidian command name.").addText(
      (text) => text.setPlaceholder("Command Name").setValue(this.commandName).onChange((value) => this.commandName = value)
    );
    new import_obsidian.Setting(contentEl).setName("Shortcut Name").setDesc("The name of the shortcut to launch.").addText(
      (text) => text.setPlaceholder("Shortcut Name").setValue(this.shortcutName).onChange((value) => this.shortcutName = value)
    );
    new import_obsidian.Setting(contentEl).setName("Input Type").setDesc("The initial input into the shortcut.").addDropdown(
      (dropdown) => dropdown.addOptions({
        "Selected Text": "Selected Text",
        "Selected Link/Embed Contents": "Selected Link/Embed Contents",
        "Current Paragraph": "Current Paragraph",
        "Entire Document": "Entire Document",
        "Link to Document": "Link to Document",
        "Document Name": "Document Name",
        "Document Path": "Document Path",
        "Backlinks to Document": "Backlinks to Document",
        Properties: "Properties",
        Multiple: "Multiple"
      }).setValue(this.inputTypes[0]).onChange((value) => {
        if (value == "Multiple") {
          this.inputTypes = [
            "Multiple",
            "Document Name",
            "Selected Text"
          ];
        } else {
          this.inputTypes = [value];
        }
        this.onOpen();
      })
    );
    if (this.inputTypes.length > 1) {
      this.inputTypes.filter((_, index) => index > 0).forEach((inputType, index) => {
        const setting = new import_obsidian.Setting(contentEl).setName(`Input Type #${index + 1}`).addDropdown(
          (dropdown) => dropdown.addOptions({
            "Selected Text": "Selected Text",
            "Selected Link/Embed Contents": "Selected Link/Embed Contents",
            "Current Paragraph": "Current Paragraph",
            "Entire Document": "Entire Document",
            "Link to Document": "Link to Document",
            "Document Name": "Document Name",
            "Document Path": "Document Path",
            "Backlinks to Document": "Backlinks to Document",
            Properties: "Properties"
          }).setValue(inputType).onChange((value) => {
            this.inputTypes[index + 1] = value;
          })
        );
        if (index > 1) {
          setting.addButton(
            (button) => button.setIcon("trash").setWarning().onClick(() => {
              this.inputTypes.splice(index + 1, 1);
              this.onOpen();
            })
          );
        }
      });
      new import_obsidian.Setting(contentEl).addButton(
        (button) => button.setButtonText("Add Input").onClick(() => {
          this.inputTypes.push("Selected Text");
          this.onOpen();
        })
      );
      new import_obsidian.Setting(contentEl).setName("Separator").setDesc("The separator to insert between input types.").addText(
        (text) => text.setValue(this.separator).onChange((value) => this.separator = value)
      );
    }
    new import_obsidian.Setting(contentEl).addButton(
      (button) => button.setButtonText("Save").setCta().onClick(() => {
        if (!this.commandName || this.commandName.length == 0) {
          return new import_obsidian.Notice("Specify a command name.");
        }
        if (!this.shortcutName || this.shortcutName.length == 0) {
          return new import_obsidian.Notice("Specify a shortcut name.");
        }
        this.onSave(
          this.commandName,
          this.shortcutName,
          this.inputTypes,
          this.separator
        );
        this.close();
      })
    );
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/SettingsTab.ts
var SettingsTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Shortcut Launchers" });
    new import_obsidian2.Setting(containerEl).addButton(
      (button) => button.setButtonText("New").setCta().onClick(() => {
        new LauncherModal(
          this.app,
          false,
          "",
          "",
          ["Selected Text"],
          ",",
          (commandName, shortcutName, inputTypes, separator) => {
            this.plugin.settings.launchers.splice(0, 0, {
              commandName,
              shortcutName,
              inputTypes,
              separator
            });
            this.plugin.saveSettings();
            this.display();
          }
        ).open();
      })
    );
    this.plugin.settings.launchers.forEach((launcher, index) => {
      new import_obsidian2.Setting(containerEl).setName(launcher.commandName).setDesc(`${launcher.shortcutName} < ${launcher.inputTypes[0]}`).addButton(
        (button) => button.setIcon("pencil").onClick((event) => {
          new LauncherModal(
            this.app,
            true,
            launcher.commandName,
            launcher.shortcutName,
            launcher.inputTypes,
            launcher.separator,
            (commandName, shortcutName, inputTypes, separator) => {
              this.plugin.settings.launchers[index].commandName = commandName;
              this.plugin.settings.launchers[index].shortcutName = shortcutName;
              this.plugin.settings.launchers[index].inputTypes = inputTypes;
              this.plugin.settings.launchers[index].separator = separator;
              this.plugin.saveSettings();
              this.display();
            }
          ).open();
        })
      ).addButton(
        (button) => button.setIcon("trash").setWarning().onClick(() => {
          this.plugin.settings.launchers.splice(index, 1);
          this.plugin.saveSettings();
          this.display();
        })
      );
    });
  }
};

// src/main.ts
var DEFAULT_SETTINGS = {
  launchers: []
};
var ShortcutLauncherPlugin = class extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    this.registeredCommands = [];
  }
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new SettingsTab(this.app, this));
    await this.createCommands();
  }
  async createCommands() {
    this.registeredCommands = [];
    this.settings.launchers.forEach((launcher) => {
      this.registeredCommands.push(
        this.addCommand({
          id: launcher.commandName.replace(/\s+/g, "-").toLowerCase(),
          name: launcher.commandName,
          checkCallback: (checking) => {
            if (checking) {
              return this.check(launcher);
            }
            const inputs = [];
            launcher.inputTypes.filter((inputType) => inputType != "Multiple").reduce(async (promise, inputType) => {
              var _a, _b, _c, _d, _e, _f;
              await promise;
              let text = "";
              if (inputType == "Selected Text") {
                text = ((_b = (_a = this.app.workspace.activeEditor) == null ? void 0 : _a.editor) == null ? void 0 : _b.getSelection()) || "";
              } else if (inputType == "Selected Link/Embed Contents") {
                const metadataCache = this.app.metadataCache.getFileCache(
                  this.app.workspace.getActiveFile()
                );
                const linksAndEmbeds = ((_c = metadataCache == null ? void 0 : metadataCache.links) != null ? _c : []).concat(
                  (_d = metadataCache == null ? void 0 : metadataCache.embeds) != null ? _d : []
                );
                const mdView = this.app.workspace.getActiveViewOfType(
                  import_obsidian3.MarkdownView
                );
                const cursorOffset = mdView.editor.posToOffset(
                  mdView.editor.getCursor()
                );
                const matchingLinkOrEmbed = linksAndEmbeds.filter(
                  (cached) => cached.position.start.offset <= cursorOffset && cached.position.end.offset >= cursorOffset
                );
                if (matchingLinkOrEmbed.length > 0) {
                  const linkpath = (0, import_obsidian3.getLinkpath)(
                    matchingLinkOrEmbed[0].link
                  );
                  const linkedFile = this.app.metadataCache.getFirstLinkpathDest(
                    linkpath,
                    this.app.workspace.getActiveFile().path
                  );
                  if (!matchingLinkOrEmbed[0].link.contains(
                    "."
                  ) || linkpath.endsWith(".md") || linkpath.endsWith("txt")) {
                    text = await this.app.vault.read(
                      linkedFile
                    );
                  } else {
                    const binary = await this.app.vault.readBinary(
                      linkedFile
                    );
                    text = arrayBufferToBase64(binary);
                  }
                } else {
                  new import_obsidian3.Notice(
                    "Could not find current link or embed"
                  );
                }
              } else if (inputType == "Current Paragraph") {
                const metadataCache = this.app.metadataCache.getFileCache(
                  this.app.workspace.getActiveFile()
                );
                if (!(metadataCache == null ? void 0 : metadataCache.sections)) {
                  new import_obsidian3.Notice(
                    "Could not find current paragraph"
                  );
                }
                const mdView = this.app.workspace.getActiveViewOfType(
                  import_obsidian3.MarkdownView
                );
                const cursorOffset = mdView.editor.posToOffset(
                  mdView.editor.getCursor()
                );
                const matchingSection = (_e = metadataCache == null ? void 0 : metadataCache.sections) == null ? void 0 : _e.filter(
                  (section) => section.position.start.offset <= cursorOffset && section.position.end.offset >= cursorOffset
                );
                if (((matchingSection == null ? void 0 : matchingSection.length) || 0) > 0) {
                  const documentContents = await this.app.vault.read(
                    this.app.workspace.getActiveFile()
                  );
                  text = documentContents.substring(
                    matchingSection[0].position.start.offset,
                    matchingSection[0].position.end.offset
                  );
                } else {
                  new import_obsidian3.Notice(
                    "Could not find current paragraph"
                  );
                }
              } else if (inputType == "Entire Document") {
                text = await this.app.vault.read(
                  this.app.workspace.getActiveFile()
                );
              } else if (inputType == "Link to Document") {
                text = `obsidian://open?vault=${encodeURIComponent(
                  this.app.vault.getName()
                )}&file=${encodeURIComponent(
                  this.app.workspace.getActiveFile().path
                )}`;
              } else if (inputType == "Document Name") {
                text = this.app.workspace.getActiveFile().basename;
              } else if (inputType == "Document Path") {
                text = this.app.workspace.getActiveFile().path;
              } else if (inputType == "Backlinks to Document") {
                const filesLinkingToActiveFile = Object.entries(
                  this.app.metadataCache.resolvedLinks
                ).filter(
                  (file) => Object.keys(file[1]).contains(
                    this.app.workspace.getActiveFile().path
                  )
                ).map((file) => file[0]);
                text = filesLinkingToActiveFile.join("\n");
              } else if (inputType == "Properties") {
                const metadataCache = this.app.metadataCache.getFileCache(
                  this.app.workspace.getActiveFile()
                );
                const frontMatter = (_f = metadataCache == null ? void 0 : metadataCache.frontmatter) != null ? _f : {};
                text = JSON.stringify(frontMatter);
              }
              inputs.push(text);
            }, Promise.resolve()).then(() => {
              if (import_obsidian3.Platform.isMobileApp) {
                window.open(
                  `shortcuts://run-shortcut?name=${encodeURIComponent(
                    launcher.shortcutName
                  )}&input=text&text=${encodeURIComponent(
                    inputs.join(launcher.separator)
                  )}`
                );
              } else {
                const tempFilePath = require("path").join(
                  require("os").tmpdir(),
                  "obsidian-shortcut-launcher-temp-input"
                );
                const escapedShortcutName = launcher.shortcutName.replace(
                  /["\\]/g,
                  "\\$&"
                );
                const fs = require("fs");
                fs.writeFile(
                  tempFilePath,
                  inputs.join(launcher.separator),
                  () => {
                    require("child_process").exec(
                      `shortcuts run "${escapedShortcutName}" -i ${tempFilePath}`,
                      async () => {
                        fs.unlink(
                          tempFilePath,
                          () => {
                          }
                        );
                      }
                    );
                  }
                );
              }
            });
            return true;
          }
        })
      );
    });
  }
  check(launcher) {
    var _a, _b, _c, _d;
    if (launcher.inputTypes.contains("Selected Text")) {
      return (((_b = (_a = this.app.workspace.activeEditor) == null ? void 0 : _a.editor) == null ? void 0 : _b.getSelection().length) || 0) > 0;
    }
    if (launcher.inputTypes.contains("Selected Link/Embed Contents")) {
      const mdView = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
      if (!mdView || mdView.getMode() !== "source") {
        return false;
      }
      const activeFile = this.app.workspace.getActiveFile();
      if (!activeFile) {
        return false;
      }
      const metadataCache = this.app.metadataCache.getFileCache(activeFile);
      if (!metadataCache) {
        return false;
      }
      const linksAndEmbeds = ((_c = metadataCache.links) != null ? _c : []).concat((_d = metadataCache.embeds) != null ? _d : []);
      if (typeof mdView.editor == "undefined") {
        return false;
      }
      const cursorOffset = mdView.editor.posToOffset(
        mdView.editor.getCursor()
      );
      const matchingLinkOrEmbed = linksAndEmbeds.filter(
        (cached) => cached.position.start.offset <= cursorOffset && cached.position.end.offset >= cursorOffset
      );
      if (matchingLinkOrEmbed.length == 0) {
        return false;
      }
    }
    if (launcher.inputTypes.contains("Current Paragraph")) {
      const mdView = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
      if (!mdView || mdView.getMode() !== "source") {
        return false;
      }
    }
    if (launcher.inputTypes.contains("Entire Document") || launcher.inputTypes.contains("Link to Document") || launcher.inputTypes.contains("Document Name") || launcher.inputTypes.contains("Document Path") || launcher.inputTypes.contains("Properties")) {
      if (!this.app.workspace.getActiveFile()) {
        return false;
      }
    }
    return true;
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.registeredCommands.forEach((command) => {
      this.app.commands.removeCommand(command.id);
    });
    this.registeredCommands = [];
    await this.createCommands();
  }
};
function arrayBufferToBase64(buffer) {
  let binary = "";
  const bytes = new Uint8Array(buffer);
  const len = bytes.byteLength;
  for (let i = 0; i < len; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return window.btoa(binary);
}

/* nosourcemap */